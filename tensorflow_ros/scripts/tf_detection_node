#!/usr/bin/env python

# System
import os
import operator
import sys

# ROS
import rospy

from sensor_msgs.msg import Image

# OpenCV
from cv_bridge import CvBridge, CvBridgeError
import cv2

import numpy as np

# object recognition
import object_tracking_msgs
from object_tracking_msgs.srv import DetectObjects
from object_tracking_msgs.msg import ObjectLocation, Hypothesis
from image_recognition_util import image_writer_test_gui
from tensorflow_ros import detector

class TensorflowDetectionNode:
    """ Performs object detection using Tensorflow neural networks """
    def __init__(self, graph_path, labels_path, save_images_folder,num_classes=99,detection_threshold=0.5,image_topic="/pepper_robot/sink/front/image_raw"):
        """ Constructor
        :param graph_path: string with path + filename (incl. extension) indicating the database location
        :param labels_path: string with path + filename (incl. extension) indicating the location of the text file
        with labels etc.
        :param save_images_folder: Where to store images for debugging or data collection
        """

        # Check if the parameters are correct
        if not (os.path.isfile(graph_path) and os.path.isfile(labels_path)):
            err_msg = "DB file {} or models file {} does not exist".format(graph_path, labels_path)
            rospy.logerr(err_msg)
            sys.exit(err_msg)
        if not (int(num_classes) > 0):
            err_msg = "invalid number of classes".format(num_classes)
            rospy.logerr(err_msg)
            sys.exit(err_msg)
        #init detector
        self.detector = detector.Detector(num_classes, detection_threshold)

        self._objectLocationList = []  # List with Detections s
        self._bridge = CvBridge()
        self._detect_srv = rospy.Service('detect', DetectObjects, self._detect_srv_callback)
        self._do_detection = False  # Indicates whether a new request has been received and thus detection must
        # be performed

        self._filename = "/tmp/tf_obj_detect.jpg"  # Temporary file name
        self._size = {'width': 0, 'height': 0}
        self._save_images_folder = save_images_folder
        self._bgr_image = None
        self.cv_image = None

        self._sub = rospy.Subscriber(image_topic, Image, self._image_callback)
        rospy.loginfo("Listening to %s -- spinning .." % self._sub.name)

        rospy.loginfo("TensorflowDetectionNode initialized:")
        rospy.loginfo(" - graph_path=%s", graph_path)
        rospy.loginfo(" - labels_path=%s", labels_path)
        rospy.loginfo(" - save_images_folder=%s", save_images_folder)
        rospy.loginfo(" - num_classes=%s", num_classes)
        rospy.loginfo(" - detection_threshold=%s", detection_threshold)

        """1. Load graph from saved GraphDef file """
        self.detector.load_graph(graph_path, labels_path)
        rospy.loginfo("detection graph successfully loaded")

    def _image_callback(self, msg):
        """
        Sensor_msgs/Image callback
        :param msg: The image message
        """
        try:
            self.cv_image = self._bridge.imgmsg_to_cv2(msg, "bgr8")
        except CvBridgeError as e:
            rospy.logerr(e)

    def _detect_srv_callback(self, req):
        """ Callback function for the detection. It saves the image on a temporary location and sets _do_detection
        to True. Subsequently, it waits until the image has been processed (i.e., until _do_detection is False again)
        and then returns the result
        :param req: object_tracking_msgs.srv.DetectRequest
        :return: object_tracking_msgs.srv.DetectResponse
        """
        try:
            self._bgr_image = self._bridge.imgmsg_to_cv2(req.image, "bgr8")
        except CvBridgeError as e:
            #error_msg = "Could not convert to opencv image: %s" % e
            #rospy.logerr(error_msg)
            #raise Exception(error_msg)
            print("no image in msg request, get one from rostopic")
            self._bgr_image = self.cv_image

        # Write the image to file
        size = self._bgr_image.shape[:2]  # For now, we assume the entire image is the ROI
        self._size['height'] = size[0]
        self._size['width'] = size[1]
        self._objectLocationList = []
        self._do_detection = True

        # Wait until the request has been processed and return the result
        r = rospy.Rate(1000.0)  # Not a problem to spin quickly
        while not rospy.is_shutdown():
            if not self._do_detection:
                return {"objectLocationList": self._objectLocationList}
        print self._objectLocationList
        # Return an empty result if rospy has been shutdown
        return {"detections": []}

    def update(self):
        """ Do the actual work: if _do_detection is True, it retrieves the saved image and tries to classify it.
        The result is stored in the _detection member and afterwards _do_detection is set to False. This function
        is called at a fixed frequency in the mean thread, hence NOT from the service callback. """
        if not self._do_detection:
            return

        classes, scores, boxes = self.detector.detect(self._bgr_image)

        # add results
        for i in range(0,len(classes)):
            objectLocation = ObjectLocation()
            hypothesis = Hypothesis(label=self.detector.get_label(classes[i]), reliability=scores[i])
            roi = boxes[i]
            objectLocation.hypotheses.append(hypothesis)
            objectLocation.bounding_box.y_offset = int(roi[0]*self._size['height'])
            objectLocation.bounding_box.x_offset = int(roi[1]*self._size['width'])
            objectLocation.bounding_box.height = int((roi[2]-roi[0])*self._size['height'])
            objectLocation.bounding_box.width = int((roi[3]-roi[1])*self._size['width'])
            self._objectLocationList.append(objectLocation)

        self._do_detection = False

if __name__ == '__main__':

    # Start ROS node
    rospy.init_node('tf_detection_ros')

    try:
        _graph_path = os.path.expanduser(rospy.get_param("~graph_path"))
        _labels_path = os.path.expanduser(rospy.get_param("~labels_path"))
        num_classes = rospy.get_param("~num_classes", 99)
        detection_threshold = rospy.get_param("~detection_threshold", 0.5)
        save_images = rospy.get_param("~save_images", True)
        image_topic = rospy.get_param("~image_topic", "/pepper_robot/sink/front/image_raw")

        save_images_folder = None
        if save_images:
            save_images_folder = os.path.expanduser(rospy.get_param("~save_images_folder", "/tmp/tensorflow_ros"))
    except KeyError as e:
        rospy.logerr("Parameter %s not found" % e)
        sys.exit(1)

    # Create object
    object_detection = TensorflowDetectionNode(graph_path=_graph_path,
                                               labels_path=_labels_path,
                                               save_images_folder=save_images_folder,
                                               num_classes=num_classes,
                                               detection_threshold=detection_threshold,
                                               image_topic=image_topic)
    # Start update loop
    r = rospy.Rate(100.0)
    while not rospy.is_shutdown():
        object_detection.update()
        r.sleep()
